/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


export interface paths {
  "/document/{identifier}": {
    /**
     * Get Document
     * @description Fetch a document from Elasticsearch with specific ID.
     */
    get: operations["get_document_document__identifier__get"];
  };
  "/search": {
    /** Search Get */
    get: operations["search_get_search_get"];
    /** Search */
    post: operations["search_search_post"];
  };
  "/autocomplete": {
    /** Taxonomy Autocomplete */
    get: operations["taxonomy_autocomplete_autocomplete_get"];
  };
  "/": {
    /** Off Demo */
    get: operations["off_demo__get"];
  };
  "/off-test": {
    /** Html Search */
    get: operations["html_search_off_test_get"];
  };
  "/robots.txt": {
    /** Robots Txt */
    get: operations["robots_txt_robots_txt_get"];
  };
  "/health": {
    /** Healthcheck */
    get: operations["healthcheck_health_get"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    /**
     * DistributionChartType
     * @description Describes an entry for a distribution chart
     */
    DistributionChartType: {
      /**
       * Chart Type
       * @default DistributionChartType
       * @constant
       * @enum {string}
       */
      chart_type?: "DistributionChartType";
      /** Field */
      field: string;
    };
    /** ErrorSearchResponse */
    ErrorSearchResponse: {
      debug: components["schemas"]["SearchResponseDebug"];
      /** Errors */
      errors: components["schemas"]["SearchResponseError"][];
    };
    /**
     * FacetInfo
     * @description Search result for a facet
     */
    FacetInfo: {
      /** Name */
      name: string;
      /** Items */
      items: components["schemas"]["FacetItem"][];
      /** Count Error Margin */
      count_error_margin?: number | null;
    };
    /**
     * FacetItem
     * @description Describes an entry of a facet
     */
    FacetItem: {
      /** Key */
      key: string;
      /** Name */
      name: string;
      /** Count */
      count: number | null;
      /** Selected */
      selected: boolean;
    };
    /** HTTPValidationError */
    HTTPValidationError: {
      /** Detail */
      detail?: components["schemas"]["ValidationError"][];
    };
    /**
     * ScatterChartType
     * @description Describes an entry for a scatter plot
     */
    ScatterChartType: {
      /**
       * Chart Type
       * @default ScatterChartType
       * @constant
       * @enum {string}
       */
      chart_type?: "ScatterChartType";
      /** X */
      x: string;
      /** Y */
      y: string;
    };
    /**
     * SearchParameters
     * @description Common parameters for search
     */
    SearchParameters: {
      /**
       * Q
       * @description The search query, it supports Lucene search query
       * syntax (https://lucene.apache.org/core/3_6_0/queryparsersyntax.html). Words
       * that are not recognized by the lucene query parser are searched as full text
       * search.
       *
       * Example: `categories_tags:"en:beverages" strawberry brands:"casino"` query use a
       * filter clause for categories and brands and look for "strawberry" in multiple
       * fields.
       *
       * The query is optional, but `sort_by` value must then be provided.
       */
      q?: string | null;
      /**
       * Langs
       * @description List of languages we want to support during search.
       * This list should include the user expected language, and additional languages (such
       * as english for example).
       *
       * This is currently used for language-specific subfields to choose in which
       * subfields we're searching in.
       *
       * If not provided, `['en']` is used.
       * @default [
       *   "en"
       * ]
       */
      langs?: string[];
      /**
       * Page Size
       * @description Number of results to return per page.
       * @default 10
       */
      page_size?: number;
      /**
       * Page
       * @description Page to request, starts at 1.
       * @default 1
       */
      page?: number;
      /**
       * Fields
       * @description List of fields to include in the response. All other fields will be ignored.
       */
      fields?: string[] | null;
      /**
       * Sort By
       * @description
       * Field name to use to sort results, the field should exist
       * and be sortable. If it is not provided, results are sorted by descending relevance score.
       *
       * If you put a minus before the name, the results will be sorted by descending order.
       *
       * If the field name match a known script (defined in your configuration),
       * it will be use for sorting.
       *
       * In this case you also need to provide additional parameters corresponding to your script parameters.
       * If a script needs parameters, you can only use the POST method.
       *
       * Beware that this may have a big [impact on performance][perf_link]
       *
       * Also bare in mind [privacy considerations][privacy_link] if your script parameters contains sensible data.
       *
       * [perf_link]: https://openfoodfacts.github.io/search-a-licious/users/how-to-use-scripts/#performance-considerations
       * [privacy_link]: https://openfoodfacts.github.io/search-a-licious/users/how-to-use-scripts/#performance-considerations
       */
      sort_by?: string | null;
      /**
       * Facets
       * @description Name of facets to return in the response as a comma-separated value.
       *             If None (default) no facets are returned.
       */
      facets?: string[] | null;
      /**
       * Charts
       * @description Name of vega representations to return in the response.
       *             Can be distribution chart or scatter plot
       */
      charts?: ((components["schemas"]["DistributionChartType"] | components["schemas"]["ScatterChartType"])[]) | null;
      /**
       * Sort Params
       * @description Additional parameters when using  a sort script in sort_by.
       *             If the sort script needs parameters, you can only be used the POST method.
       */
      sort_params?: Record<string, never> | null;
      /**
       * Index Id
       * @description Index ID to use for the search, if not provided, the default index is used.
       *         If there is only one index, this parameter is not needed.
       */
      index_id?: string | null;
    };
    /** SearchResponseDebug */
    SearchResponseDebug: {
      /** Query */
      query: Record<string, never>;
    };
    /** SearchResponseError */
    SearchResponseError: {
      /** Title */
      title: string;
      /** Description */
      description?: string | null;
    };
    /** SuccessSearchResponse */
    SuccessSearchResponse: {
      /** Hits */
      hits: Record<string, never>[];
      /** Aggregations */
      aggregations?: Record<string, never> | null;
      /** Facets */
      facets?: {
        [key: string]: components["schemas"]["FacetInfo"];
      } | null;
      /** Charts */
      charts?: {
        [key: string]: Record<string, never>;
      } | null;
      /** Page */
      page: number;
      /** Page Size */
      page_size: number;
      /** Page Count */
      page_count: number;
      debug: components["schemas"]["SearchResponseDebug"];
      /** Took */
      took: number;
      /** Timed Out */
      timed_out: boolean;
      /** Count */
      count: number;
      /** Is Count Exact */
      is_count_exact: boolean;
      /** Warnings */
      warnings?: components["schemas"]["SearchResponseError"][] | null;
    };
    /** ValidationError */
    ValidationError: {
      /** Location */
      loc: (string | number)[];
      /** Message */
      msg: string;
      /** Error Type */
      type: string;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {

  /**
   * Get Document
   * @description Fetch a document from Elasticsearch with specific ID.
   */
  get_document_document__identifier__get: {
    parameters: {
      query?: {
        /**
         * @description Index ID to use for the search, if not provided, the default index is used.
         *         If there is only one index, this parameter is not needed.
         */
        index_id?: string | null;
      };
      path: {
        identifier: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Search Get */
  search_get_search_get: {
    parameters: {
      query?: {
        /**
         * @description The search query, it supports Lucene search query
         * syntax (https://lucene.apache.org/core/3_6_0/queryparsersyntax.html). Words
         * that are not recognized by the lucene query parser are searched as full text
         * search.
         *
         * Example: `categories_tags:"en:beverages" strawberry brands:"casino"` query use a
         * filter clause for categories and brands and look for "strawberry" in multiple
         * fields.
         *
         * The query is optional, but `sort_by` value must then be provided.
         */
        q?: string | null;
        /**
         * @description List of languages we want to support during search.
         * This list should include the user expected language, and additional languages (such
         * as english for example).
         *
         * This is currently used for language-specific subfields to choose in which
         * subfields we're searching in.
         *
         * If not provided, `['en']` is used.
         */
        langs?: string;
        /** @description Number of results to return per page. */
        page_size?: number;
        /** @description Page to request, starts at 1. */
        page?: number;
        /** @description List of fields to include in the response. All other fields will be ignored. */
        fields?: string;
        /**
         * @description
         * Field name to use to sort results, the field should exist
         * and be sortable. If it is not provided, results are sorted by descending relevance score.
         *
         * If you put a minus before the name, the results will be sorted by descending order.
         *
         * If the field name match a known script (defined in your configuration),
         * it will be use for sorting.
         *
         * In this case you also need to provide additional parameters corresponding to your script parameters.
         * If a script needs parameters, you can only use the POST method.
         *
         * Beware that this may have a big [impact on performance][perf_link]
         *
         * Also bare in mind [privacy considerations][privacy_link] if your script parameters contains sensible data.
         *
         * [perf_link]: https://openfoodfacts.github.io/search-a-licious/users/how-to-use-scripts/#performance-considerations
         * [privacy_link]: https://openfoodfacts.github.io/search-a-licious/users/how-to-use-scripts/#performance-considerations
         */
        sort_by?: string | null;
        /**
         * @description Name of facets to return in the response as a comma-separated value.
         *             If None (default) no facets are returned.
         */
        facets?: string;
        /**
         * @description Name of vega representations to return in the response.
         *             Can be distribution chart or scatter plot
         */
        charts?: string;
        /**
         * @description Index ID to use for the search, if not provided, the default index is used.
         *         If there is only one index, this parameter is not needed.
         */
        index_id?: string | null;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ErrorSearchResponse"] | components["schemas"]["SuccessSearchResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Search */
  search_search_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SearchParameters"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Taxonomy Autocomplete */
  taxonomy_autocomplete_autocomplete_get: {
    parameters: {
      query: {
        /** @description User autocomplete query. */
        q: string;
        /** @description Name(s) of the taxonomy to search in, as a comma-separated value. */
        taxonomy_names: string;
        /** @description Language to search in, defaults to 'en'. */
        lang?: string;
        /** @description Number of results to return. */
        size?: number;
        /** @description Fuzziness level to use, default to no fuzziness. */
        fuzziness?: number | null;
        /**
         * @description Index ID to use for the search, if not provided, the default index is used.
         *         If there is only one index, this parameter is not needed.
         */
        index_id?: string | null;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Off Demo */
  off_demo__get: {
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "text/html": string;
        };
      };
    };
  };
  /** Html Search */
  html_search_off_test_get: {
    parameters: {
      query?: {
        q?: string | null;
        page?: number;
        page_size?: number;
        langs?: string;
        sort_by?: string | null;
        /**
         * @description Index ID to use for the search, if not provided, the default index is used.
         *         If there is only one index, this parameter is not needed.
         */
        index_id?: string | null;
        display_debug?: boolean;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "text/html": string;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Robots Txt */
  robots_txt_robots_txt_get: {
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "text/plain": string;
        };
      };
    };
  };
  /** Healthcheck */
  healthcheck_health_get: {
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
    };
  };
}
